/*
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_DATALOADING_KV_SERVER_H_
#define FLATBUFFERS_GENERATED_DATALOADING_KV_SERVER_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 2 &&
                  FLATBUFFERS_VERSION_MINOR == 0 &&
                  FLATBUFFERS_VERSION_REVISION == 8,
              "Non-compatible flatbuffers version included");

namespace kv_server {

struct StringValue;
struct StringValueBuilder;
struct StringValueT;

struct StringSet;
struct StringSetBuilder;
struct StringSetT;

struct UInt32Set;
struct UInt32SetBuilder;
struct UInt32SetT;

struct KeyValueMutationRecord;
struct KeyValueMutationRecordBuilder;
struct KeyValueMutationRecordT;

struct UserDefinedFunctionsConfig;
struct UserDefinedFunctionsConfigBuilder;
struct UserDefinedFunctionsConfigT;

struct ShardMappingRecord;
struct ShardMappingRecordBuilder;
struct ShardMappingRecordT;

struct DataRecord;
struct DataRecordBuilder;
struct DataRecordT;

bool operator==(const StringValueT& lhs, const StringValueT& rhs);
bool operator!=(const StringValueT& lhs, const StringValueT& rhs);
bool operator==(const StringSetT& lhs, const StringSetT& rhs);
bool operator!=(const StringSetT& lhs, const StringSetT& rhs);
bool operator==(const UInt32SetT& lhs, const UInt32SetT& rhs);
bool operator!=(const UInt32SetT& lhs, const UInt32SetT& rhs);
bool operator==(const KeyValueMutationRecordT& lhs,
                const KeyValueMutationRecordT& rhs);
bool operator!=(const KeyValueMutationRecordT& lhs,
                const KeyValueMutationRecordT& rhs);
bool operator==(const UserDefinedFunctionsConfigT& lhs,
                const UserDefinedFunctionsConfigT& rhs);
bool operator!=(const UserDefinedFunctionsConfigT& lhs,
                const UserDefinedFunctionsConfigT& rhs);
bool operator==(const ShardMappingRecordT& lhs, const ShardMappingRecordT& rhs);
bool operator!=(const ShardMappingRecordT& lhs, const ShardMappingRecordT& rhs);
bool operator==(const DataRecordT& lhs, const DataRecordT& rhs);
bool operator!=(const DataRecordT& lhs, const DataRecordT& rhs);

enum class KeyValueMutationType : int8_t {
  Update = 0,
  Delete = 1,
  MIN = Update,
  MAX = Delete
};

inline const KeyValueMutationType (&EnumValuesKeyValueMutationType())[2] {
  static const KeyValueMutationType values[] = {KeyValueMutationType::Update,
                                                KeyValueMutationType::Delete};
  return values;
}

inline const char* const* EnumNamesKeyValueMutationType() {
  static const char* const names[3] = {"Update", "Delete", nullptr};
  return names;
}

inline const char* EnumNameKeyValueMutationType(KeyValueMutationType e) {
  if (flatbuffers::IsOutRange(e, KeyValueMutationType::Update,
                              KeyValueMutationType::Delete))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesKeyValueMutationType()[index];
}

enum class Value : uint8_t {
  NONE = 0,
  StringValue = 1,
  StringSet = 2,
  UInt32Set = 3,
  MIN = NONE,
  MAX = UInt32Set
};

inline const Value (&EnumValuesValue())[4] {
  static const Value values[] = {Value::NONE, Value::StringValue,
                                 Value::StringSet, Value::UInt32Set};
  return values;
}

inline const char* const* EnumNamesValue() {
  static const char* const names[5] = {"NONE", "StringValue", "StringSet",
                                       "UInt32Set", nullptr};
  return names;
}

inline const char* EnumNameValue(Value e) {
  if (flatbuffers::IsOutRange(e, Value::NONE, Value::UInt32Set)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesValue()[index];
}

template <typename T>
struct ValueTraits {
  static const Value enum_value = Value::NONE;
};

template <>
struct ValueTraits<kv_server::StringValue> {
  static const Value enum_value = Value::StringValue;
};

template <>
struct ValueTraits<kv_server::StringSet> {
  static const Value enum_value = Value::StringSet;
};

template <>
struct ValueTraits<kv_server::UInt32Set> {
  static const Value enum_value = Value::UInt32Set;
};

template <typename T>
struct ValueUnionTraits {
  static const Value enum_value = Value::NONE;
};

template <>
struct ValueUnionTraits<kv_server::StringValueT> {
  static const Value enum_value = Value::StringValue;
};

template <>
struct ValueUnionTraits<kv_server::StringSetT> {
  static const Value enum_value = Value::StringSet;
};

template <>
struct ValueUnionTraits<kv_server::UInt32SetT> {
  static const Value enum_value = Value::UInt32Set;
};

struct ValueUnion {
  Value type;
  void* value;

  ValueUnion() : type(Value::NONE), value(nullptr) {}
  ValueUnion(ValueUnion&& u) FLATBUFFERS_NOEXCEPT : type(Value::NONE),
                                                    value(nullptr) {
    std::swap(type, u.type);
    std::swap(value, u.value);
  }
  ValueUnion(const ValueUnion&);
  ValueUnion& operator=(const ValueUnion& u) {
    ValueUnion t(u);
    std::swap(type, t.type);
    std::swap(value, t.value);
    return *this;
  }
  ValueUnion& operator=(ValueUnion&& u) FLATBUFFERS_NOEXCEPT {
    std::swap(type, u.type);
    std::swap(value, u.value);
    return *this;
  }
  ~ValueUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = ValueUnionTraits<RT>::enum_value;
    if (type != Value::NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void* UnPack(const void* obj, Value type,
                      const flatbuffers::resolver_function_t* resolver);
  flatbuffers::Offset<void> Pack(
      flatbuffers::FlatBufferBuilder& _fbb,
      const flatbuffers::rehasher_function_t* _rehasher = nullptr) const;

  kv_server::StringValueT* AsStringValue() {
    return type == Value::StringValue
               ? reinterpret_cast<kv_server::StringValueT*>(value)
               : nullptr;
  }
  const kv_server::StringValueT* AsStringValue() const {
    return type == Value::StringValue
               ? reinterpret_cast<const kv_server::StringValueT*>(value)
               : nullptr;
  }
  kv_server::StringSetT* AsStringSet() {
    return type == Value::StringSet
               ? reinterpret_cast<kv_server::StringSetT*>(value)
               : nullptr;
  }
  const kv_server::StringSetT* AsStringSet() const {
    return type == Value::StringSet
               ? reinterpret_cast<const kv_server::StringSetT*>(value)
               : nullptr;
  }
  kv_server::UInt32SetT* AsUInt32Set() {
    return type == Value::UInt32Set
               ? reinterpret_cast<kv_server::UInt32SetT*>(value)
               : nullptr;
  }
  const kv_server::UInt32SetT* AsUInt32Set() const {
    return type == Value::UInt32Set
               ? reinterpret_cast<const kv_server::UInt32SetT*>(value)
               : nullptr;
  }
};

inline bool operator==(const ValueUnion& lhs, const ValueUnion& rhs) {
  if (lhs.type != rhs.type) return false;
  switch (lhs.type) {
    case Value::NONE: {
      return true;
    }
    case Value::StringValue: {
      return *(reinterpret_cast<const kv_server::StringValueT*>(lhs.value)) ==
             *(reinterpret_cast<const kv_server::StringValueT*>(rhs.value));
    }
    case Value::StringSet: {
      return *(reinterpret_cast<const kv_server::StringSetT*>(lhs.value)) ==
             *(reinterpret_cast<const kv_server::StringSetT*>(rhs.value));
    }
    case Value::UInt32Set: {
      return *(reinterpret_cast<const kv_server::UInt32SetT*>(lhs.value)) ==
             *(reinterpret_cast<const kv_server::UInt32SetT*>(rhs.value));
    }
    default: {
      return false;
    }
  }
}

inline bool operator!=(const ValueUnion& lhs, const ValueUnion& rhs) {
  return !(lhs == rhs);
}

bool VerifyValue(flatbuffers::Verifier& verifier, const void* obj, Value type);
bool VerifyValueVector(
    flatbuffers::Verifier& verifier,
    const flatbuffers::Vector<flatbuffers::Offset<void>>* values,
    const flatbuffers::Vector<Value>* types);

enum class UserDefinedFunctionsLanguage : int8_t {
  Javascript = 0,
  MIN = Javascript,
  MAX = Javascript
};

inline const UserDefinedFunctionsLanguage (
    &EnumValuesUserDefinedFunctionsLanguage())[1] {
  static const UserDefinedFunctionsLanguage values[] = {
      UserDefinedFunctionsLanguage::Javascript};
  return values;
}

inline const char* const* EnumNamesUserDefinedFunctionsLanguage() {
  static const char* const names[2] = {"Javascript", nullptr};
  return names;
}

inline const char* EnumNameUserDefinedFunctionsLanguage(
    UserDefinedFunctionsLanguage e) {
  if (flatbuffers::IsOutRange(e, UserDefinedFunctionsLanguage::Javascript,
                              UserDefinedFunctionsLanguage::Javascript))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesUserDefinedFunctionsLanguage()[index];
}

enum class Record : uint8_t {
  NONE = 0,
  KeyValueMutationRecord = 1,
  UserDefinedFunctionsConfig = 2,
  ShardMappingRecord = 3,
  MIN = NONE,
  MAX = ShardMappingRecord
};

inline const Record (&EnumValuesRecord())[4] {
  static const Record values[] = {Record::NONE, Record::KeyValueMutationRecord,
                                  Record::UserDefinedFunctionsConfig,
                                  Record::ShardMappingRecord};
  return values;
}

inline const char* const* EnumNamesRecord() {
  static const char* const names[5] = {"NONE", "KeyValueMutationRecord",
                                       "UserDefinedFunctionsConfig",
                                       "ShardMappingRecord", nullptr};
  return names;
}

inline const char* EnumNameRecord(Record e) {
  if (flatbuffers::IsOutRange(e, Record::NONE, Record::ShardMappingRecord))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRecord()[index];
}

template <typename T>
struct RecordTraits {
  static const Record enum_value = Record::NONE;
};

template <>
struct RecordTraits<kv_server::KeyValueMutationRecord> {
  static const Record enum_value = Record::KeyValueMutationRecord;
};

template <>
struct RecordTraits<kv_server::UserDefinedFunctionsConfig> {
  static const Record enum_value = Record::UserDefinedFunctionsConfig;
};

template <>
struct RecordTraits<kv_server::ShardMappingRecord> {
  static const Record enum_value = Record::ShardMappingRecord;
};

template <typename T>
struct RecordUnionTraits {
  static const Record enum_value = Record::NONE;
};

template <>
struct RecordUnionTraits<kv_server::KeyValueMutationRecordT> {
  static const Record enum_value = Record::KeyValueMutationRecord;
};

template <>
struct RecordUnionTraits<kv_server::UserDefinedFunctionsConfigT> {
  static const Record enum_value = Record::UserDefinedFunctionsConfig;
};

template <>
struct RecordUnionTraits<kv_server::ShardMappingRecordT> {
  static const Record enum_value = Record::ShardMappingRecord;
};

struct RecordUnion {
  Record type;
  void* value;

  RecordUnion() : type(Record::NONE), value(nullptr) {}
  RecordUnion(RecordUnion&& u) FLATBUFFERS_NOEXCEPT : type(Record::NONE),
                                                      value(nullptr) {
    std::swap(type, u.type);
    std::swap(value, u.value);
  }
  RecordUnion(const RecordUnion&);
  RecordUnion& operator=(const RecordUnion& u) {
    RecordUnion t(u);
    std::swap(type, t.type);
    std::swap(value, t.value);
    return *this;
  }
  RecordUnion& operator=(RecordUnion&& u) FLATBUFFERS_NOEXCEPT {
    std::swap(type, u.type);
    std::swap(value, u.value);
    return *this;
  }
  ~RecordUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = RecordUnionTraits<RT>::enum_value;
    if (type != Record::NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void* UnPack(const void* obj, Record type,
                      const flatbuffers::resolver_function_t* resolver);
  flatbuffers::Offset<void> Pack(
      flatbuffers::FlatBufferBuilder& _fbb,
      const flatbuffers::rehasher_function_t* _rehasher = nullptr) const;

  kv_server::KeyValueMutationRecordT* AsKeyValueMutationRecord() {
    return type == Record::KeyValueMutationRecord
               ? reinterpret_cast<kv_server::KeyValueMutationRecordT*>(value)
               : nullptr;
  }
  const kv_server::KeyValueMutationRecordT* AsKeyValueMutationRecord() const {
    return type == Record::KeyValueMutationRecord
               ? reinterpret_cast<const kv_server::KeyValueMutationRecordT*>(
                     value)
               : nullptr;
  }
  kv_server::UserDefinedFunctionsConfigT* AsUserDefinedFunctionsConfig() {
    return type == Record::UserDefinedFunctionsConfig
               ? reinterpret_cast<kv_server::UserDefinedFunctionsConfigT*>(
                     value)
               : nullptr;
  }
  const kv_server::UserDefinedFunctionsConfigT* AsUserDefinedFunctionsConfig()
      const {
    return type == Record::UserDefinedFunctionsConfig
               ? reinterpret_cast<
                     const kv_server::UserDefinedFunctionsConfigT*>(value)
               : nullptr;
  }
  kv_server::ShardMappingRecordT* AsShardMappingRecord() {
    return type == Record::ShardMappingRecord
               ? reinterpret_cast<kv_server::ShardMappingRecordT*>(value)
               : nullptr;
  }
  const kv_server::ShardMappingRecordT* AsShardMappingRecord() const {
    return type == Record::ShardMappingRecord
               ? reinterpret_cast<const kv_server::ShardMappingRecordT*>(value)
               : nullptr;
  }
};

inline bool operator==(const RecordUnion& lhs, const RecordUnion& rhs) {
  if (lhs.type != rhs.type) return false;
  switch (lhs.type) {
    case Record::NONE: {
      return true;
    }
    case Record::KeyValueMutationRecord: {
      return *(reinterpret_cast<const kv_server::KeyValueMutationRecordT*>(
                 lhs.value)) ==
             *(reinterpret_cast<const kv_server::KeyValueMutationRecordT*>(
                 rhs.value));
    }
    case Record::UserDefinedFunctionsConfig: {
      return *(reinterpret_cast<const kv_server::UserDefinedFunctionsConfigT*>(
                 lhs.value)) ==
             *(reinterpret_cast<const kv_server::UserDefinedFunctionsConfigT*>(
                 rhs.value));
    }
    case Record::ShardMappingRecord: {
      return *(reinterpret_cast<const kv_server::ShardMappingRecordT*>(
                 lhs.value)) ==
             *(reinterpret_cast<const kv_server::ShardMappingRecordT*>(
                 rhs.value));
    }
    default: {
      return false;
    }
  }
}

inline bool operator!=(const RecordUnion& lhs, const RecordUnion& rhs) {
  return !(lhs == rhs);
}

bool VerifyRecord(flatbuffers::Verifier& verifier, const void* obj,
                  Record type);
bool VerifyRecordVector(
    flatbuffers::Verifier& verifier,
    const flatbuffers::Vector<flatbuffers::Offset<void>>* values,
    const flatbuffers::Vector<Record>* types);

struct StringValueT : public flatbuffers::NativeTable {
  typedef StringValue TableType;
  std::string value{};
};

struct StringValue FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StringValueT NativeTableType;
  typedef StringValueBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const flatbuffers::String* value() const {
    return GetPointer<const flatbuffers::String*>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) && verifier.EndTable();
  }
  StringValueT* UnPack(
      const flatbuffers::resolver_function_t* _resolver = nullptr) const;
  void UnPackTo(
      StringValueT* _o,
      const flatbuffers::resolver_function_t* _resolver = nullptr) const;
  static flatbuffers::Offset<StringValue> Pack(
      flatbuffers::FlatBufferBuilder& _fbb, const StringValueT* _o,
      const flatbuffers::rehasher_function_t* _rehasher = nullptr);
};

struct StringValueBuilder {
  typedef StringValue Table;
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::String> value) {
    fbb_.AddOffset(StringValue::VT_VALUE, value);
  }
  explicit StringValueBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<StringValue> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StringValue>(end);
    return o;
  }
};

inline flatbuffers::Offset<StringValue> CreateStringValue(
    flatbuffers::FlatBufferBuilder& _fbb,
    flatbuffers::Offset<flatbuffers::String> value = 0) {
  StringValueBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct StringValue::Traits {
  using type = StringValue;
  static auto constexpr Create = CreateStringValue;
};

inline flatbuffers::Offset<StringValue> CreateStringValueDirect(
    flatbuffers::FlatBufferBuilder& _fbb, const char* value = nullptr) {
  auto value__ = value ? _fbb.CreateString(value) : 0;
  return kv_server::CreateStringValue(_fbb, value__);
}

flatbuffers::Offset<StringValue> CreateStringValue(
    flatbuffers::FlatBufferBuilder& _fbb, const StringValueT* _o,
    const flatbuffers::rehasher_function_t* _rehasher = nullptr);

struct StringSetT : public flatbuffers::NativeTable {
  typedef StringSet TableType;
  std::vector<std::string> value{};
};

struct StringSet FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StringSetT NativeTableType;
  typedef StringSetBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>* value()
      const {
    return GetPointer<
        const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>*>(
        VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.VerifyVectorOfStrings(value()) && verifier.EndTable();
  }
  StringSetT* UnPack(
      const flatbuffers::resolver_function_t* _resolver = nullptr) const;
  void UnPackTo(
      StringSetT* _o,
      const flatbuffers::resolver_function_t* _resolver = nullptr) const;
  static flatbuffers::Offset<StringSet> Pack(
      flatbuffers::FlatBufferBuilder& _fbb, const StringSetT* _o,
      const flatbuffers::rehasher_function_t* _rehasher = nullptr);
};

struct StringSetBuilder {
  typedef StringSet Table;
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<
                 flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>>
                     value) {
    fbb_.AddOffset(StringSet::VT_VALUE, value);
  }
  explicit StringSetBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<StringSet> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StringSet>(end);
    return o;
  }
};

inline flatbuffers::Offset<StringSet> CreateStringSet(
    flatbuffers::FlatBufferBuilder& _fbb,
    flatbuffers::Offset<
        flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>>
        value = 0) {
  StringSetBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct StringSet::Traits {
  using type = StringSet;
  static auto constexpr Create = CreateStringSet;
};

inline flatbuffers::Offset<StringSet> CreateStringSetDirect(
    flatbuffers::FlatBufferBuilder& _fbb,
    const std::vector<flatbuffers::Offset<flatbuffers::String>>* value =
        nullptr) {
  auto value__ =
      value
          ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*value)
          : 0;
  return kv_server::CreateStringSet(_fbb, value__);
}

flatbuffers::Offset<StringSet> CreateStringSet(
    flatbuffers::FlatBufferBuilder& _fbb, const StringSetT* _o,
    const flatbuffers::rehasher_function_t* _rehasher = nullptr);

struct UInt32SetT : public flatbuffers::NativeTable {
  typedef UInt32Set TableType;
  std::vector<uint32_t> value{};
};

struct UInt32Set FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UInt32SetT NativeTableType;
  typedef UInt32SetBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const flatbuffers::Vector<uint32_t>* value() const {
    return GetPointer<const flatbuffers::Vector<uint32_t>*>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) && verifier.EndTable();
  }
  UInt32SetT* UnPack(
      const flatbuffers::resolver_function_t* _resolver = nullptr) const;
  void UnPackTo(
      UInt32SetT* _o,
      const flatbuffers::resolver_function_t* _resolver = nullptr) const;
  static flatbuffers::Offset<UInt32Set> Pack(
      flatbuffers::FlatBufferBuilder& _fbb, const UInt32SetT* _o,
      const flatbuffers::rehasher_function_t* _rehasher = nullptr);
};

struct UInt32SetBuilder {
  typedef UInt32Set Table;
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> value) {
    fbb_.AddOffset(UInt32Set::VT_VALUE, value);
  }
  explicit UInt32SetBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<UInt32Set> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UInt32Set>(end);
    return o;
  }
};

inline flatbuffers::Offset<UInt32Set> CreateUInt32Set(
    flatbuffers::FlatBufferBuilder& _fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> value = 0) {
  UInt32SetBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct UInt32Set::Traits {
  using type = UInt32Set;
  static auto constexpr Create = CreateUInt32Set;
};

inline flatbuffers::Offset<UInt32Set> CreateUInt32SetDirect(
    flatbuffers::FlatBufferBuilder& _fbb,
    const std::vector<uint32_t>* value = nullptr) {
  auto value__ = value ? _fbb.CreateVector<uint32_t>(*value) : 0;
  return kv_server::CreateUInt32Set(_fbb, value__);
}

flatbuffers::Offset<UInt32Set> CreateUInt32Set(
    flatbuffers::FlatBufferBuilder& _fbb, const UInt32SetT* _o,
    const flatbuffers::rehasher_function_t* _rehasher = nullptr);

struct KeyValueMutationRecordT : public flatbuffers::NativeTable {
  typedef KeyValueMutationRecord TableType;
  kv_server::KeyValueMutationType mutation_type =
      kv_server::KeyValueMutationType::Update;
  int64_t logical_commit_time = 0;
  std::string key{};
  kv_server::ValueUnion value{};
};

struct KeyValueMutationRecord FLATBUFFERS_FINAL_CLASS
    : private flatbuffers::Table {
  typedef KeyValueMutationRecordT NativeTableType;
  typedef KeyValueMutationRecordBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MUTATION_TYPE = 4,
    VT_LOGICAL_COMMIT_TIME = 6,
    VT_KEY = 8,
    VT_VALUE_TYPE = 10,
    VT_VALUE = 12
  };
  kv_server::KeyValueMutationType mutation_type() const {
    return static_cast<kv_server::KeyValueMutationType>(
        GetField<int8_t>(VT_MUTATION_TYPE, 0));
  }
  int64_t logical_commit_time() const {
    return GetField<int64_t>(VT_LOGICAL_COMMIT_TIME, 0);
  }
  const flatbuffers::String* key() const {
    return GetPointer<const flatbuffers::String*>(VT_KEY);
  }
  kv_server::Value value_type() const {
    return static_cast<kv_server::Value>(GetField<uint8_t>(VT_VALUE_TYPE, 0));
  }
  const void* value() const { return GetPointer<const void*>(VT_VALUE); }
  template <typename T>
  const T* value_as() const;
  const kv_server::StringValue* value_as_StringValue() const {
    return value_type() == kv_server::Value::StringValue
               ? static_cast<const kv_server::StringValue*>(value())
               : nullptr;
  }
  const kv_server::StringSet* value_as_StringSet() const {
    return value_type() == kv_server::Value::StringSet
               ? static_cast<const kv_server::StringSet*>(value())
               : nullptr;
  }
  const kv_server::UInt32Set* value_as_UInt32Set() const {
    return value_type() == kv_server::Value::UInt32Set
               ? static_cast<const kv_server::UInt32Set*>(value())
               : nullptr;
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_MUTATION_TYPE, 1) &&
           VerifyField<int64_t>(verifier, VT_LOGICAL_COMMIT_TIME, 8) &&
           VerifyOffset(verifier, VT_KEY) && verifier.VerifyString(key()) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE, 1) &&
           VerifyOffset(verifier, VT_VALUE) &&
           VerifyValue(verifier, value(), value_type()) && verifier.EndTable();
  }
  KeyValueMutationRecordT* UnPack(
      const flatbuffers::resolver_function_t* _resolver = nullptr) const;
  void UnPackTo(
      KeyValueMutationRecordT* _o,
      const flatbuffers::resolver_function_t* _resolver = nullptr) const;
  static flatbuffers::Offset<KeyValueMutationRecord> Pack(
      flatbuffers::FlatBufferBuilder& _fbb, const KeyValueMutationRecordT* _o,
      const flatbuffers::rehasher_function_t* _rehasher = nullptr);
};

template <>
inline const kv_server::StringValue*
KeyValueMutationRecord::value_as<kv_server::StringValue>() const {
  return value_as_StringValue();
}

template <>
inline const kv_server::StringSet*
KeyValueMutationRecord::value_as<kv_server::StringSet>() const {
  return value_as_StringSet();
}

template <>
inline const kv_server::UInt32Set*
KeyValueMutationRecord::value_as<kv_server::UInt32Set>() const {
  return value_as_UInt32Set();
}

struct KeyValueMutationRecordBuilder {
  typedef KeyValueMutationRecord Table;
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_mutation_type(kv_server::KeyValueMutationType mutation_type) {
    fbb_.AddElement<int8_t>(KeyValueMutationRecord::VT_MUTATION_TYPE,
                            static_cast<int8_t>(mutation_type), 0);
  }
  void add_logical_commit_time(int64_t logical_commit_time) {
    fbb_.AddElement<int64_t>(KeyValueMutationRecord::VT_LOGICAL_COMMIT_TIME,
                             logical_commit_time, 0);
  }
  void add_key(flatbuffers::Offset<flatbuffers::String> key) {
    fbb_.AddOffset(KeyValueMutationRecord::VT_KEY, key);
  }
  void add_value_type(kv_server::Value value_type) {
    fbb_.AddElement<uint8_t>(KeyValueMutationRecord::VT_VALUE_TYPE,
                             static_cast<uint8_t>(value_type), 0);
  }
  void add_value(flatbuffers::Offset<void> value) {
    fbb_.AddOffset(KeyValueMutationRecord::VT_VALUE, value);
  }
  explicit KeyValueMutationRecordBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<KeyValueMutationRecord> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<KeyValueMutationRecord>(end);
    return o;
  }
};

inline flatbuffers::Offset<KeyValueMutationRecord> CreateKeyValueMutationRecord(
    flatbuffers::FlatBufferBuilder& _fbb,
    kv_server::KeyValueMutationType mutation_type =
        kv_server::KeyValueMutationType::Update,
    int64_t logical_commit_time = 0,
    flatbuffers::Offset<flatbuffers::String> key = 0,
    kv_server::Value value_type = kv_server::Value::NONE,
    flatbuffers::Offset<void> value = 0) {
  KeyValueMutationRecordBuilder builder_(_fbb);
  builder_.add_logical_commit_time(logical_commit_time);
  builder_.add_value(value);
  builder_.add_key(key);
  builder_.add_value_type(value_type);
  builder_.add_mutation_type(mutation_type);
  return builder_.Finish();
}

struct KeyValueMutationRecord::Traits {
  using type = KeyValueMutationRecord;
  static auto constexpr Create = CreateKeyValueMutationRecord;
};

inline flatbuffers::Offset<KeyValueMutationRecord>
CreateKeyValueMutationRecordDirect(
    flatbuffers::FlatBufferBuilder& _fbb,
    kv_server::KeyValueMutationType mutation_type =
        kv_server::KeyValueMutationType::Update,
    int64_t logical_commit_time = 0, const char* key = nullptr,
    kv_server::Value value_type = kv_server::Value::NONE,
    flatbuffers::Offset<void> value = 0) {
  auto key__ = key ? _fbb.CreateString(key) : 0;
  return kv_server::CreateKeyValueMutationRecord(
      _fbb, mutation_type, logical_commit_time, key__, value_type, value);
}

flatbuffers::Offset<KeyValueMutationRecord> CreateKeyValueMutationRecord(
    flatbuffers::FlatBufferBuilder& _fbb, const KeyValueMutationRecordT* _o,
    const flatbuffers::rehasher_function_t* _rehasher = nullptr);

struct UserDefinedFunctionsConfigT : public flatbuffers::NativeTable {
  typedef UserDefinedFunctionsConfig TableType;
  kv_server::UserDefinedFunctionsLanguage language =
      kv_server::UserDefinedFunctionsLanguage::Javascript;
  std::string code_snippet{};
  std::string handler_name{};
  int64_t logical_commit_time = 0;
  int64_t version = 0;
};

struct UserDefinedFunctionsConfig FLATBUFFERS_FINAL_CLASS
    : private flatbuffers::Table {
  typedef UserDefinedFunctionsConfigT NativeTableType;
  typedef UserDefinedFunctionsConfigBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LANGUAGE = 4,
    VT_CODE_SNIPPET = 6,
    VT_HANDLER_NAME = 8,
    VT_LOGICAL_COMMIT_TIME = 10,
    VT_VERSION = 12
  };
  kv_server::UserDefinedFunctionsLanguage language() const {
    return static_cast<kv_server::UserDefinedFunctionsLanguage>(
        GetField<int8_t>(VT_LANGUAGE, 0));
  }
  const flatbuffers::String* code_snippet() const {
    return GetPointer<const flatbuffers::String*>(VT_CODE_SNIPPET);
  }
  const flatbuffers::String* handler_name() const {
    return GetPointer<const flatbuffers::String*>(VT_HANDLER_NAME);
  }
  int64_t logical_commit_time() const {
    return GetField<int64_t>(VT_LOGICAL_COMMIT_TIME, 0);
  }
  int64_t version() const { return GetField<int64_t>(VT_VERSION, 0); }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_LANGUAGE, 1) &&
           VerifyOffset(verifier, VT_CODE_SNIPPET) &&
           verifier.VerifyString(code_snippet()) &&
           VerifyOffset(verifier, VT_HANDLER_NAME) &&
           verifier.VerifyString(handler_name()) &&
           VerifyField<int64_t>(verifier, VT_LOGICAL_COMMIT_TIME, 8) &&
           VerifyField<int64_t>(verifier, VT_VERSION, 8) && verifier.EndTable();
  }
  UserDefinedFunctionsConfigT* UnPack(
      const flatbuffers::resolver_function_t* _resolver = nullptr) const;
  void UnPackTo(
      UserDefinedFunctionsConfigT* _o,
      const flatbuffers::resolver_function_t* _resolver = nullptr) const;
  static flatbuffers::Offset<UserDefinedFunctionsConfig> Pack(
      flatbuffers::FlatBufferBuilder& _fbb,
      const UserDefinedFunctionsConfigT* _o,
      const flatbuffers::rehasher_function_t* _rehasher = nullptr);
};

struct UserDefinedFunctionsConfigBuilder {
  typedef UserDefinedFunctionsConfig Table;
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_language(kv_server::UserDefinedFunctionsLanguage language) {
    fbb_.AddElement<int8_t>(UserDefinedFunctionsConfig::VT_LANGUAGE,
                            static_cast<int8_t>(language), 0);
  }
  void add_code_snippet(flatbuffers::Offset<flatbuffers::String> code_snippet) {
    fbb_.AddOffset(UserDefinedFunctionsConfig::VT_CODE_SNIPPET, code_snippet);
  }
  void add_handler_name(flatbuffers::Offset<flatbuffers::String> handler_name) {
    fbb_.AddOffset(UserDefinedFunctionsConfig::VT_HANDLER_NAME, handler_name);
  }
  void add_logical_commit_time(int64_t logical_commit_time) {
    fbb_.AddElement<int64_t>(UserDefinedFunctionsConfig::VT_LOGICAL_COMMIT_TIME,
                             logical_commit_time, 0);
  }
  void add_version(int64_t version) {
    fbb_.AddElement<int64_t>(UserDefinedFunctionsConfig::VT_VERSION, version,
                             0);
  }
  explicit UserDefinedFunctionsConfigBuilder(
      flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<UserDefinedFunctionsConfig> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UserDefinedFunctionsConfig>(end);
    return o;
  }
};

inline flatbuffers::Offset<UserDefinedFunctionsConfig>
CreateUserDefinedFunctionsConfig(
    flatbuffers::FlatBufferBuilder& _fbb,
    kv_server::UserDefinedFunctionsLanguage language =
        kv_server::UserDefinedFunctionsLanguage::Javascript,
    flatbuffers::Offset<flatbuffers::String> code_snippet = 0,
    flatbuffers::Offset<flatbuffers::String> handler_name = 0,
    int64_t logical_commit_time = 0, int64_t version = 0) {
  UserDefinedFunctionsConfigBuilder builder_(_fbb);
  builder_.add_version(version);
  builder_.add_logical_commit_time(logical_commit_time);
  builder_.add_handler_name(handler_name);
  builder_.add_code_snippet(code_snippet);
  builder_.add_language(language);
  return builder_.Finish();
}

struct UserDefinedFunctionsConfig::Traits {
  using type = UserDefinedFunctionsConfig;
  static auto constexpr Create = CreateUserDefinedFunctionsConfig;
};

inline flatbuffers::Offset<UserDefinedFunctionsConfig>
CreateUserDefinedFunctionsConfigDirect(
    flatbuffers::FlatBufferBuilder& _fbb,
    kv_server::UserDefinedFunctionsLanguage language =
        kv_server::UserDefinedFunctionsLanguage::Javascript,
    const char* code_snippet = nullptr, const char* handler_name = nullptr,
    int64_t logical_commit_time = 0, int64_t version = 0) {
  auto code_snippet__ = code_snippet ? _fbb.CreateString(code_snippet) : 0;
  auto handler_name__ = handler_name ? _fbb.CreateString(handler_name) : 0;
  return kv_server::CreateUserDefinedFunctionsConfig(
      _fbb, language, code_snippet__, handler_name__, logical_commit_time,
      version);
}

flatbuffers::Offset<UserDefinedFunctionsConfig>
CreateUserDefinedFunctionsConfig(
    flatbuffers::FlatBufferBuilder& _fbb, const UserDefinedFunctionsConfigT* _o,
    const flatbuffers::rehasher_function_t* _rehasher = nullptr);

struct ShardMappingRecordT : public flatbuffers::NativeTable {
  typedef ShardMappingRecord TableType;
  int32_t logical_shard = 0;
  int32_t physical_shard = 0;
};

struct ShardMappingRecord FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ShardMappingRecordT NativeTableType;
  typedef ShardMappingRecordBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LOGICAL_SHARD = 4,
    VT_PHYSICAL_SHARD = 6
  };
  int32_t logical_shard() const {
    return GetField<int32_t>(VT_LOGICAL_SHARD, 0);
  }
  int32_t physical_shard() const {
    return GetField<int32_t>(VT_PHYSICAL_SHARD, 0);
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_LOGICAL_SHARD, 4) &&
           VerifyField<int32_t>(verifier, VT_PHYSICAL_SHARD, 4) &&
           verifier.EndTable();
  }
  ShardMappingRecordT* UnPack(
      const flatbuffers::resolver_function_t* _resolver = nullptr) const;
  void UnPackTo(
      ShardMappingRecordT* _o,
      const flatbuffers::resolver_function_t* _resolver = nullptr) const;
  static flatbuffers::Offset<ShardMappingRecord> Pack(
      flatbuffers::FlatBufferBuilder& _fbb, const ShardMappingRecordT* _o,
      const flatbuffers::rehasher_function_t* _rehasher = nullptr);
};

struct ShardMappingRecordBuilder {
  typedef ShardMappingRecord Table;
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_logical_shard(int32_t logical_shard) {
    fbb_.AddElement<int32_t>(ShardMappingRecord::VT_LOGICAL_SHARD,
                             logical_shard, 0);
  }
  void add_physical_shard(int32_t physical_shard) {
    fbb_.AddElement<int32_t>(ShardMappingRecord::VT_PHYSICAL_SHARD,
                             physical_shard, 0);
  }
  explicit ShardMappingRecordBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ShardMappingRecord> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ShardMappingRecord>(end);
    return o;
  }
};

inline flatbuffers::Offset<ShardMappingRecord> CreateShardMappingRecord(
    flatbuffers::FlatBufferBuilder& _fbb, int32_t logical_shard = 0,
    int32_t physical_shard = 0) {
  ShardMappingRecordBuilder builder_(_fbb);
  builder_.add_physical_shard(physical_shard);
  builder_.add_logical_shard(logical_shard);
  return builder_.Finish();
}

struct ShardMappingRecord::Traits {
  using type = ShardMappingRecord;
  static auto constexpr Create = CreateShardMappingRecord;
};

flatbuffers::Offset<ShardMappingRecord> CreateShardMappingRecord(
    flatbuffers::FlatBufferBuilder& _fbb, const ShardMappingRecordT* _o,
    const flatbuffers::rehasher_function_t* _rehasher = nullptr);

struct DataRecordT : public flatbuffers::NativeTable {
  typedef DataRecord TableType;
  kv_server::RecordUnion record{};
};

struct DataRecord FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DataRecordT NativeTableType;
  typedef DataRecordBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RECORD_TYPE = 4,
    VT_RECORD = 6
  };
  kv_server::Record record_type() const {
    return static_cast<kv_server::Record>(GetField<uint8_t>(VT_RECORD_TYPE, 0));
  }
  const void* record() const { return GetPointer<const void*>(VT_RECORD); }
  template <typename T>
  const T* record_as() const;
  const kv_server::KeyValueMutationRecord* record_as_KeyValueMutationRecord()
      const {
    return record_type() == kv_server::Record::KeyValueMutationRecord
               ? static_cast<const kv_server::KeyValueMutationRecord*>(record())
               : nullptr;
  }
  const kv_server::UserDefinedFunctionsConfig*
  record_as_UserDefinedFunctionsConfig() const {
    return record_type() == kv_server::Record::UserDefinedFunctionsConfig
               ? static_cast<const kv_server::UserDefinedFunctionsConfig*>(
                     record())
               : nullptr;
  }
  const kv_server::ShardMappingRecord* record_as_ShardMappingRecord() const {
    return record_type() == kv_server::Record::ShardMappingRecord
               ? static_cast<const kv_server::ShardMappingRecord*>(record())
               : nullptr;
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_RECORD_TYPE, 1) &&
           VerifyOffset(verifier, VT_RECORD) &&
           VerifyRecord(verifier, record(), record_type()) &&
           verifier.EndTable();
  }
  DataRecordT* UnPack(
      const flatbuffers::resolver_function_t* _resolver = nullptr) const;
  void UnPackTo(
      DataRecordT* _o,
      const flatbuffers::resolver_function_t* _resolver = nullptr) const;
  static flatbuffers::Offset<DataRecord> Pack(
      flatbuffers::FlatBufferBuilder& _fbb, const DataRecordT* _o,
      const flatbuffers::rehasher_function_t* _rehasher = nullptr);
};

template <>
inline const kv_server::KeyValueMutationRecord*
DataRecord::record_as<kv_server::KeyValueMutationRecord>() const {
  return record_as_KeyValueMutationRecord();
}

template <>
inline const kv_server::UserDefinedFunctionsConfig*
DataRecord::record_as<kv_server::UserDefinedFunctionsConfig>() const {
  return record_as_UserDefinedFunctionsConfig();
}

template <>
inline const kv_server::ShardMappingRecord*
DataRecord::record_as<kv_server::ShardMappingRecord>() const {
  return record_as_ShardMappingRecord();
}

struct DataRecordBuilder {
  typedef DataRecord Table;
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_record_type(kv_server::Record record_type) {
    fbb_.AddElement<uint8_t>(DataRecord::VT_RECORD_TYPE,
                             static_cast<uint8_t>(record_type), 0);
  }
  void add_record(flatbuffers::Offset<void> record) {
    fbb_.AddOffset(DataRecord::VT_RECORD, record);
  }
  explicit DataRecordBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DataRecord> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DataRecord>(end);
    return o;
  }
};

inline flatbuffers::Offset<DataRecord> CreateDataRecord(
    flatbuffers::FlatBufferBuilder& _fbb,
    kv_server::Record record_type = kv_server::Record::NONE,
    flatbuffers::Offset<void> record = 0) {
  DataRecordBuilder builder_(_fbb);
  builder_.add_record(record);
  builder_.add_record_type(record_type);
  return builder_.Finish();
}

struct DataRecord::Traits {
  using type = DataRecord;
  static auto constexpr Create = CreateDataRecord;
};

flatbuffers::Offset<DataRecord> CreateDataRecord(
    flatbuffers::FlatBufferBuilder& _fbb, const DataRecordT* _o,
    const flatbuffers::rehasher_function_t* _rehasher = nullptr);

inline bool operator==(const StringValueT& lhs, const StringValueT& rhs) {
  return (lhs.value == rhs.value);
}

inline bool operator!=(const StringValueT& lhs, const StringValueT& rhs) {
  return !(lhs == rhs);
}

inline StringValueT* StringValue::UnPack(
    const flatbuffers::resolver_function_t* _resolver) const {
  auto _o = std::make_unique<StringValueT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void StringValue::UnPackTo(
    StringValueT* _o, const flatbuffers::resolver_function_t* _resolver) const {
  (void)_o;
  (void)_resolver;
  {
    auto _e = value();
    if (_e) _o->value = _e->str();
  }
}

inline flatbuffers::Offset<StringValue> StringValue::Pack(
    flatbuffers::FlatBufferBuilder& _fbb, const StringValueT* _o,
    const flatbuffers::rehasher_function_t* _rehasher) {
  return CreateStringValue(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<StringValue> CreateStringValue(
    flatbuffers::FlatBufferBuilder& _fbb, const StringValueT* _o,
    const flatbuffers::rehasher_function_t* _rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs {
    flatbuffers::FlatBufferBuilder* __fbb;
    const StringValueT* __o;
    const flatbuffers::rehasher_function_t* __rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _value = _o->value.empty() ? 0 : _fbb.CreateString(_o->value);
  return kv_server::CreateStringValue(_fbb, _value);
}

inline bool operator==(const StringSetT& lhs, const StringSetT& rhs) {
  return (lhs.value == rhs.value);
}

inline bool operator!=(const StringSetT& lhs, const StringSetT& rhs) {
  return !(lhs == rhs);
}

inline StringSetT* StringSet::UnPack(
    const flatbuffers::resolver_function_t* _resolver) const {
  auto _o = std::make_unique<StringSetT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void StringSet::UnPackTo(
    StringSetT* _o, const flatbuffers::resolver_function_t* _resolver) const {
  (void)_o;
  (void)_resolver;
  {
    auto _e = value();
    if (_e) {
      _o->value.resize(_e->size());
      for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
        _o->value[_i] = _e->Get(_i)->str();
      }
    }
  }
}

inline flatbuffers::Offset<StringSet> StringSet::Pack(
    flatbuffers::FlatBufferBuilder& _fbb, const StringSetT* _o,
    const flatbuffers::rehasher_function_t* _rehasher) {
  return CreateStringSet(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<StringSet> CreateStringSet(
    flatbuffers::FlatBufferBuilder& _fbb, const StringSetT* _o,
    const flatbuffers::rehasher_function_t* _rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs {
    flatbuffers::FlatBufferBuilder* __fbb;
    const StringSetT* __o;
    const flatbuffers::rehasher_function_t* __rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _value = _o->value.size() ? _fbb.CreateVectorOfStrings(_o->value) : 0;
  return kv_server::CreateStringSet(_fbb, _value);
}

inline bool operator==(const UInt32SetT& lhs, const UInt32SetT& rhs) {
  return (lhs.value == rhs.value);
}

inline bool operator!=(const UInt32SetT& lhs, const UInt32SetT& rhs) {
  return !(lhs == rhs);
}

inline UInt32SetT* UInt32Set::UnPack(
    const flatbuffers::resolver_function_t* _resolver) const {
  auto _o = std::make_unique<UInt32SetT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void UInt32Set::UnPackTo(
    UInt32SetT* _o, const flatbuffers::resolver_function_t* _resolver) const {
  (void)_o;
  (void)_resolver;
  {
    auto _e = value();
    if (_e) {
      _o->value.resize(_e->size());
      for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
        _o->value[_i] = _e->Get(_i);
      }
    }
  }
}

inline flatbuffers::Offset<UInt32Set> UInt32Set::Pack(
    flatbuffers::FlatBufferBuilder& _fbb, const UInt32SetT* _o,
    const flatbuffers::rehasher_function_t* _rehasher) {
  return CreateUInt32Set(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UInt32Set> CreateUInt32Set(
    flatbuffers::FlatBufferBuilder& _fbb, const UInt32SetT* _o,
    const flatbuffers::rehasher_function_t* _rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs {
    flatbuffers::FlatBufferBuilder* __fbb;
    const UInt32SetT* __o;
    const flatbuffers::rehasher_function_t* __rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _value = _o->value.size() ? _fbb.CreateVector(_o->value) : 0;
  return kv_server::CreateUInt32Set(_fbb, _value);
}

inline bool operator==(const KeyValueMutationRecordT& lhs,
                       const KeyValueMutationRecordT& rhs) {
  return (lhs.mutation_type == rhs.mutation_type) &&
         (lhs.logical_commit_time == rhs.logical_commit_time) &&
         (lhs.key == rhs.key) && (lhs.value == rhs.value);
}

inline bool operator!=(const KeyValueMutationRecordT& lhs,
                       const KeyValueMutationRecordT& rhs) {
  return !(lhs == rhs);
}

inline KeyValueMutationRecordT* KeyValueMutationRecord::UnPack(
    const flatbuffers::resolver_function_t* _resolver) const {
  auto _o = std::make_unique<KeyValueMutationRecordT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void KeyValueMutationRecord::UnPackTo(
    KeyValueMutationRecordT* _o,
    const flatbuffers::resolver_function_t* _resolver) const {
  (void)_o;
  (void)_resolver;
  {
    auto _e = mutation_type();
    _o->mutation_type = _e;
  }
  {
    auto _e = logical_commit_time();
    _o->logical_commit_time = _e;
  }
  {
    auto _e = key();
    if (_e) _o->key = _e->str();
  }
  {
    auto _e = value_type();
    _o->value.type = _e;
  }
  {
    auto _e = value();
    if (_e)
      _o->value.value =
          kv_server::ValueUnion::UnPack(_e, value_type(), _resolver);
  }
}

inline flatbuffers::Offset<KeyValueMutationRecord> KeyValueMutationRecord::Pack(
    flatbuffers::FlatBufferBuilder& _fbb, const KeyValueMutationRecordT* _o,
    const flatbuffers::rehasher_function_t* _rehasher) {
  return CreateKeyValueMutationRecord(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<KeyValueMutationRecord> CreateKeyValueMutationRecord(
    flatbuffers::FlatBufferBuilder& _fbb, const KeyValueMutationRecordT* _o,
    const flatbuffers::rehasher_function_t* _rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs {
    flatbuffers::FlatBufferBuilder* __fbb;
    const KeyValueMutationRecordT* __o;
    const flatbuffers::rehasher_function_t* __rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _mutation_type = _o->mutation_type;
  auto _logical_commit_time = _o->logical_commit_time;
  auto _key = _o->key.empty() ? 0 : _fbb.CreateString(_o->key);
  auto _value_type = _o->value.type;
  auto _value = _o->value.Pack(_fbb);
  return kv_server::CreateKeyValueMutationRecord(
      _fbb, _mutation_type, _logical_commit_time, _key, _value_type, _value);
}

inline bool operator==(const UserDefinedFunctionsConfigT& lhs,
                       const UserDefinedFunctionsConfigT& rhs) {
  return (lhs.language == rhs.language) &&
         (lhs.code_snippet == rhs.code_snippet) &&
         (lhs.handler_name == rhs.handler_name) &&
         (lhs.logical_commit_time == rhs.logical_commit_time) &&
         (lhs.version == rhs.version);
}

inline bool operator!=(const UserDefinedFunctionsConfigT& lhs,
                       const UserDefinedFunctionsConfigT& rhs) {
  return !(lhs == rhs);
}

inline UserDefinedFunctionsConfigT* UserDefinedFunctionsConfig::UnPack(
    const flatbuffers::resolver_function_t* _resolver) const {
  auto _o = std::make_unique<UserDefinedFunctionsConfigT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void UserDefinedFunctionsConfig::UnPackTo(
    UserDefinedFunctionsConfigT* _o,
    const flatbuffers::resolver_function_t* _resolver) const {
  (void)_o;
  (void)_resolver;
  {
    auto _e = language();
    _o->language = _e;
  }
  {
    auto _e = code_snippet();
    if (_e) _o->code_snippet = _e->str();
  }
  {
    auto _e = handler_name();
    if (_e) _o->handler_name = _e->str();
  }
  {
    auto _e = logical_commit_time();
    _o->logical_commit_time = _e;
  }
  {
    auto _e = version();
    _o->version = _e;
  }
}

inline flatbuffers::Offset<UserDefinedFunctionsConfig>
UserDefinedFunctionsConfig::Pack(
    flatbuffers::FlatBufferBuilder& _fbb, const UserDefinedFunctionsConfigT* _o,
    const flatbuffers::rehasher_function_t* _rehasher) {
  return CreateUserDefinedFunctionsConfig(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UserDefinedFunctionsConfig>
CreateUserDefinedFunctionsConfig(
    flatbuffers::FlatBufferBuilder& _fbb, const UserDefinedFunctionsConfigT* _o,
    const flatbuffers::rehasher_function_t* _rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs {
    flatbuffers::FlatBufferBuilder* __fbb;
    const UserDefinedFunctionsConfigT* __o;
    const flatbuffers::rehasher_function_t* __rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _language = _o->language;
  auto _code_snippet =
      _o->code_snippet.empty() ? 0 : _fbb.CreateString(_o->code_snippet);
  auto _handler_name =
      _o->handler_name.empty() ? 0 : _fbb.CreateString(_o->handler_name);
  auto _logical_commit_time = _o->logical_commit_time;
  auto _version = _o->version;
  return kv_server::CreateUserDefinedFunctionsConfig(
      _fbb, _language, _code_snippet, _handler_name, _logical_commit_time,
      _version);
}

inline bool operator==(const ShardMappingRecordT& lhs,
                       const ShardMappingRecordT& rhs) {
  return (lhs.logical_shard == rhs.logical_shard) &&
         (lhs.physical_shard == rhs.physical_shard);
}

inline bool operator!=(const ShardMappingRecordT& lhs,
                       const ShardMappingRecordT& rhs) {
  return !(lhs == rhs);
}

inline ShardMappingRecordT* ShardMappingRecord::UnPack(
    const flatbuffers::resolver_function_t* _resolver) const {
  auto _o = std::make_unique<ShardMappingRecordT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ShardMappingRecord::UnPackTo(
    ShardMappingRecordT* _o,
    const flatbuffers::resolver_function_t* _resolver) const {
  (void)_o;
  (void)_resolver;
  {
    auto _e = logical_shard();
    _o->logical_shard = _e;
  }
  {
    auto _e = physical_shard();
    _o->physical_shard = _e;
  }
}

inline flatbuffers::Offset<ShardMappingRecord> ShardMappingRecord::Pack(
    flatbuffers::FlatBufferBuilder& _fbb, const ShardMappingRecordT* _o,
    const flatbuffers::rehasher_function_t* _rehasher) {
  return CreateShardMappingRecord(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ShardMappingRecord> CreateShardMappingRecord(
    flatbuffers::FlatBufferBuilder& _fbb, const ShardMappingRecordT* _o,
    const flatbuffers::rehasher_function_t* _rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs {
    flatbuffers::FlatBufferBuilder* __fbb;
    const ShardMappingRecordT* __o;
    const flatbuffers::rehasher_function_t* __rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _logical_shard = _o->logical_shard;
  auto _physical_shard = _o->physical_shard;
  return kv_server::CreateShardMappingRecord(_fbb, _logical_shard,
                                             _physical_shard);
}

inline bool operator==(const DataRecordT& lhs, const DataRecordT& rhs) {
  return (lhs.record == rhs.record);
}

inline bool operator!=(const DataRecordT& lhs, const DataRecordT& rhs) {
  return !(lhs == rhs);
}

inline DataRecordT* DataRecord::UnPack(
    const flatbuffers::resolver_function_t* _resolver) const {
  auto _o = std::make_unique<DataRecordT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DataRecord::UnPackTo(
    DataRecordT* _o, const flatbuffers::resolver_function_t* _resolver) const {
  (void)_o;
  (void)_resolver;
  {
    auto _e = record_type();
    _o->record.type = _e;
  }
  {
    auto _e = record();
    if (_e)
      _o->record.value =
          kv_server::RecordUnion::UnPack(_e, record_type(), _resolver);
  }
}

inline flatbuffers::Offset<DataRecord> DataRecord::Pack(
    flatbuffers::FlatBufferBuilder& _fbb, const DataRecordT* _o,
    const flatbuffers::rehasher_function_t* _rehasher) {
  return CreateDataRecord(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DataRecord> CreateDataRecord(
    flatbuffers::FlatBufferBuilder& _fbb, const DataRecordT* _o,
    const flatbuffers::rehasher_function_t* _rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs {
    flatbuffers::FlatBufferBuilder* __fbb;
    const DataRecordT* __o;
    const flatbuffers::rehasher_function_t* __rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _record_type = _o->record.type;
  auto _record = _o->record.Pack(_fbb);
  return kv_server::CreateDataRecord(_fbb, _record_type, _record);
}

inline bool VerifyValue(flatbuffers::Verifier& verifier, const void* obj,
                        Value type) {
  switch (type) {
    case Value::NONE: {
      return true;
    }
    case Value::StringValue: {
      auto ptr = reinterpret_cast<const kv_server::StringValue*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value::StringSet: {
      auto ptr = reinterpret_cast<const kv_server::StringSet*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value::UInt32Set: {
      auto ptr = reinterpret_cast<const kv_server::UInt32Set*>(obj);
      return verifier.VerifyTable(ptr);
    }
    default:
      return true;
  }
}

inline bool VerifyValueVector(
    flatbuffers::Verifier& verifier,
    const flatbuffers::Vector<flatbuffers::Offset<void>>* values,
    const flatbuffers::Vector<Value>* types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyValue(verifier, values->Get(i), types->GetEnum<Value>(i))) {
      return false;
    }
  }
  return true;
}

inline void* ValueUnion::UnPack(
    const void* obj, Value type,
    const flatbuffers::resolver_function_t* resolver) {
  (void)resolver;
  switch (type) {
    case Value::StringValue: {
      auto ptr = reinterpret_cast<const kv_server::StringValue*>(obj);
      return ptr->UnPack(resolver);
    }
    case Value::StringSet: {
      auto ptr = reinterpret_cast<const kv_server::StringSet*>(obj);
      return ptr->UnPack(resolver);
    }
    case Value::UInt32Set: {
      auto ptr = reinterpret_cast<const kv_server::UInt32Set*>(obj);
      return ptr->UnPack(resolver);
    }
    default:
      return nullptr;
  }
}

inline flatbuffers::Offset<void> ValueUnion::Pack(
    flatbuffers::FlatBufferBuilder& _fbb,
    const flatbuffers::rehasher_function_t* _rehasher) const {
  (void)_rehasher;
  switch (type) {
    case Value::StringValue: {
      auto ptr = reinterpret_cast<const kv_server::StringValueT*>(value);
      return CreateStringValue(_fbb, ptr, _rehasher).Union();
    }
    case Value::StringSet: {
      auto ptr = reinterpret_cast<const kv_server::StringSetT*>(value);
      return CreateStringSet(_fbb, ptr, _rehasher).Union();
    }
    case Value::UInt32Set: {
      auto ptr = reinterpret_cast<const kv_server::UInt32SetT*>(value);
      return CreateUInt32Set(_fbb, ptr, _rehasher).Union();
    }
    default:
      return 0;
  }
}

inline ValueUnion::ValueUnion(const ValueUnion& u)
    : type(u.type), value(nullptr) {
  switch (type) {
    case Value::StringValue: {
      value = new kv_server::StringValueT(
          *reinterpret_cast<kv_server::StringValueT*>(u.value));
      break;
    }
    case Value::StringSet: {
      value = new kv_server::StringSetT(
          *reinterpret_cast<kv_server::StringSetT*>(u.value));
      break;
    }
    case Value::UInt32Set: {
      value = new kv_server::UInt32SetT(
          *reinterpret_cast<kv_server::UInt32SetT*>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void ValueUnion::Reset() {
  switch (type) {
    case Value::StringValue: {
      auto ptr = reinterpret_cast<kv_server::StringValueT*>(value);
      delete ptr;
      break;
    }
    case Value::StringSet: {
      auto ptr = reinterpret_cast<kv_server::StringSetT*>(value);
      delete ptr;
      break;
    }
    case Value::UInt32Set: {
      auto ptr = reinterpret_cast<kv_server::UInt32SetT*>(value);
      delete ptr;
      break;
    }
    default:
      break;
  }
  value = nullptr;
  type = Value::NONE;
}

inline bool VerifyRecord(flatbuffers::Verifier& verifier, const void* obj,
                         Record type) {
  switch (type) {
    case Record::NONE: {
      return true;
    }
    case Record::KeyValueMutationRecord: {
      auto ptr =
          reinterpret_cast<const kv_server::KeyValueMutationRecord*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Record::UserDefinedFunctionsConfig: {
      auto ptr =
          reinterpret_cast<const kv_server::UserDefinedFunctionsConfig*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Record::ShardMappingRecord: {
      auto ptr = reinterpret_cast<const kv_server::ShardMappingRecord*>(obj);
      return verifier.VerifyTable(ptr);
    }
    default:
      return true;
  }
}

inline bool VerifyRecordVector(
    flatbuffers::Verifier& verifier,
    const flatbuffers::Vector<flatbuffers::Offset<void>>* values,
    const flatbuffers::Vector<Record>* types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyRecord(verifier, values->Get(i), types->GetEnum<Record>(i))) {
      return false;
    }
  }
  return true;
}

inline void* RecordUnion::UnPack(
    const void* obj, Record type,
    const flatbuffers::resolver_function_t* resolver) {
  (void)resolver;
  switch (type) {
    case Record::KeyValueMutationRecord: {
      auto ptr =
          reinterpret_cast<const kv_server::KeyValueMutationRecord*>(obj);
      return ptr->UnPack(resolver);
    }
    case Record::UserDefinedFunctionsConfig: {
      auto ptr =
          reinterpret_cast<const kv_server::UserDefinedFunctionsConfig*>(obj);
      return ptr->UnPack(resolver);
    }
    case Record::ShardMappingRecord: {
      auto ptr = reinterpret_cast<const kv_server::ShardMappingRecord*>(obj);
      return ptr->UnPack(resolver);
    }
    default:
      return nullptr;
  }
}

inline flatbuffers::Offset<void> RecordUnion::Pack(
    flatbuffers::FlatBufferBuilder& _fbb,
    const flatbuffers::rehasher_function_t* _rehasher) const {
  (void)_rehasher;
  switch (type) {
    case Record::KeyValueMutationRecord: {
      auto ptr =
          reinterpret_cast<const kv_server::KeyValueMutationRecordT*>(value);
      return CreateKeyValueMutationRecord(_fbb, ptr, _rehasher).Union();
    }
    case Record::UserDefinedFunctionsConfig: {
      auto ptr =
          reinterpret_cast<const kv_server::UserDefinedFunctionsConfigT*>(
              value);
      return CreateUserDefinedFunctionsConfig(_fbb, ptr, _rehasher).Union();
    }
    case Record::ShardMappingRecord: {
      auto ptr = reinterpret_cast<const kv_server::ShardMappingRecordT*>(value);
      return CreateShardMappingRecord(_fbb, ptr, _rehasher).Union();
    }
    default:
      return 0;
  }
}

inline RecordUnion::RecordUnion(const RecordUnion& u)
    : type(u.type), value(nullptr) {
  switch (type) {
    case Record::KeyValueMutationRecord: {
      value = new kv_server::KeyValueMutationRecordT(
          *reinterpret_cast<kv_server::KeyValueMutationRecordT*>(u.value));
      break;
    }
    case Record::UserDefinedFunctionsConfig: {
      value = new kv_server::UserDefinedFunctionsConfigT(
          *reinterpret_cast<kv_server::UserDefinedFunctionsConfigT*>(u.value));
      break;
    }
    case Record::ShardMappingRecord: {
      value = new kv_server::ShardMappingRecordT(
          *reinterpret_cast<kv_server::ShardMappingRecordT*>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void RecordUnion::Reset() {
  switch (type) {
    case Record::KeyValueMutationRecord: {
      auto ptr = reinterpret_cast<kv_server::KeyValueMutationRecordT*>(value);
      delete ptr;
      break;
    }
    case Record::UserDefinedFunctionsConfig: {
      auto ptr =
          reinterpret_cast<kv_server::UserDefinedFunctionsConfigT*>(value);
      delete ptr;
      break;
    }
    case Record::ShardMappingRecord: {
      auto ptr = reinterpret_cast<kv_server::ShardMappingRecordT*>(value);
      delete ptr;
      break;
    }
    default:
      break;
  }
  value = nullptr;
  type = Record::NONE;
}

inline const kv_server::DataRecord* GetDataRecord(const void* buf) {
  return flatbuffers::GetRoot<kv_server::DataRecord>(buf);
}

inline const kv_server::DataRecord* GetSizePrefixedDataRecord(const void* buf) {
  return flatbuffers::GetSizePrefixedRoot<kv_server::DataRecord>(buf);
}

inline bool VerifyDataRecordBuffer(flatbuffers::Verifier& verifier) {
  return verifier.VerifyBuffer<kv_server::DataRecord>(nullptr);
}

inline bool VerifySizePrefixedDataRecordBuffer(
    flatbuffers::Verifier& verifier) {
  return verifier.VerifySizePrefixedBuffer<kv_server::DataRecord>(nullptr);
}

inline void FinishDataRecordBuffer(
    flatbuffers::FlatBufferBuilder& fbb,
    flatbuffers::Offset<kv_server::DataRecord> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedDataRecordBuffer(
    flatbuffers::FlatBufferBuilder& fbb,
    flatbuffers::Offset<kv_server::DataRecord> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<kv_server::DataRecordT> UnPackDataRecord(
    const void* buf, const flatbuffers::resolver_function_t* res = nullptr) {
  return std::unique_ptr<kv_server::DataRecordT>(
      GetDataRecord(buf)->UnPack(res));
}

inline std::unique_ptr<kv_server::DataRecordT> UnPackSizePrefixedDataRecord(
    const void* buf, const flatbuffers::resolver_function_t* res = nullptr) {
  return std::unique_ptr<kv_server::DataRecordT>(
      GetSizePrefixedDataRecord(buf)->UnPack(res));
}

}  // namespace kv_server

#endif  // FLATBUFFERS_GENERATED_DATALOADING_KV_SERVER_H_
