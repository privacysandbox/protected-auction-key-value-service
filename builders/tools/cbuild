#!/usr/bin/env bash

# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

set -o pipefail
set -o errexit

IMAGE="build-debian"
VERBOSE=0
declare -r -a IMAGE_LIST=(
  "build-debian"
  "build-amazonlinux2"
  "presubmit"
)

declare -a ENV_VARS
ENV_VARS+=(
  "BAZEL_STARTUP_ARGS"
  "BAZEL_EXTRA_ARGS"
)

usage() {
  local exitval=${1-1}
  cat &>/dev/stderr << USAGE
usage:
  $0 <options>
    --cmd                      Command(s) to execute within the docker container, via \`bash -c\`
    --image                    Image name for the build runtime. Valid names:
USAGE

  for elem in "${IMAGE_LIST[@]}"
  do
    printf "                                   *  %s\n" "${elem}" &>/dev/stderr
  done

  cat &>/dev/stderr << USAGE
    --env <key>[=<value>]      Name (or name=value) of exported environment variable, propagated into container
    --without-shared-cache     Containers will not mount ${HOME}/.cache/bazel
    --without-embedded-docker  Disable docker client within container
    --verbose                  Enable verbose output

Environment variables (all optional):
    WORKSPACE                    Full path to the workspace (repo root)
    EXTRA_DOCKER_RUN_ARGS        Additional arguments to pass to docker run invocations

Environment variables propagated into container:
    BAZEL_STARTUP_ARGS
    BAZEL_EXTRA_ARGS
USAGE
  # shellcheck disable=SC2086
  exit ${exitval}
}

WITH_SHARED_CACHE=1
WITH_DOCKER_SOCK=1

while [[ $# -gt 0 ]]; do
  case "$1" in
    --cmd)
      CMD="$2"
      shift
      shift
      ;;
    --env)
      ENV_VARS+=("$2")
      shift
      shift
      ;;
    --image)
      IMAGE="$2"
      shift
      shift
      ;;
    --without-shared-cache)
      WITH_SHARED_CACHE=0
      shift
      ;;
    --without-embedded-docker)
      WITH_DOCKER_SOCK=0
      shift
      ;;
    --verbose)
      VERBOSE=1
      shift
      ;;
    -h | --help)
      usage 0
      break
      ;;
    *)
      printf "unrecognized arg: %s\n" "$1"
      usage
      break
      ;;
  esac
done

if [[ -z ${IMAGE} ]]; then
  printf -- "error: --image must be specified\n" &>/dev/stderr
  usage 1
fi
# shellcheck disable=SC2076
if ! [[ " ${IMAGE_LIST[*]} " =~ " ${IMAGE} " ]]; then
    printf -- "error: image [%s] not recognized\n" "${IMAGE}" &>/dev/stderr
      usage 1
fi

SCRIPT_DIR="$(dirname "$(readlink -f "$0")")"
WORKSPACE="${WORKSPACE-"$(readlink -f "${SCRIPT_DIR}"/../..)"}"

# if running inside a docker container, the workspace mount point cannot be
# determined by git or bazel or inspecting the filesystem itself. Instead, we
# need to use docker to expose its mount info for the /src/workspace path.
if [[ -f /.dockerenv ]]; then
  # determine the current container's ID
  CONTAINER_ID=$(uname --nodename)
  # use docker inspect to extract the current mount path for /src/workspace
  # this format string is a golang template (https://pkg.go.dev/text/template) processed
  # by docker's --format flag, per https://docs.docker.com/config/formatting/
  # shellcheck disable=SC2016
  declare -r FORMAT_STR='
    {{- range $v := .HostConfig.Binds -}}
      {{$pathpair := split $v ":" -}}
      {{if eq (index $pathpair 1) "/src/workspace" -}}
        {{print (index $pathpair 0) -}}
      {{end -}}
    {{end -}}
  '
  WORKSPACE_MOUNT="$(docker inspect --format "${FORMAT_STR}" "${CONTAINER_ID}")"
  readonly WORKSPACE_MOUNT
  if [[ -z ${WORKSPACE_MOUNT} ]]; then
    printf "Unable to determine mount point for /src/workspace. Exiting\n" &>/dev/stderr
    exit 1
  fi
else
  WORKSPACE_MOUNT="${WORKSPACE}"
fi
if [[ ${VERBOSE} -eq 1 ]]; then
  printf "mounting workspace into container: %s\n" "${WORKSPACE_MOUNT}" &>/dev/stderr
fi

IMAGE_TAGGED="$("${WORKSPACE}"/builders/tools/get-builder-image-tagged --image "${IMAGE}")"
readonly IMAGE_TAGGED

declare -a DOCKER_RUN_ARGS
DOCKER_RUN_ARGS+=(
  "--rm"
  "--entrypoint=/bin/bash"
  "--volume ${WORKSPACE_MOUNT}:/src/workspace"
  "--workdir /src/workspace"
  "${EXTRA_DOCKER_RUN_ARGS}"
)

# inside the docker build images, /bazel_root is the bazel cache dir, per the system-wide bazelrc
readonly BAZEL_ROOT=/bazel_root
if [[ ${WITH_SHARED_CACHE} -eq 0 ]]; then
  # use tmpfs for as temporary, container-bound bazel cache
  DOCKER_RUN_ARGS+=(
    "--tmpfs ${BAZEL_ROOT}:exec"
  )
else
  # mount host filesystem for "shared" use by multiple docker container invocations
  DOCKER_RUN_ARGS+=(
    "--volume ${HOME}/.cache/bazel:${BAZEL_ROOT}"
  )
fi
if [[ ${WITH_DOCKER_SOCK} -eq 1 ]]; then
  DOCKER_RUN_ARGS+=(
    "--volume /var/run/docker.sock:/var/run/docker.sock"
  )
fi
for evar in "${ENV_VARS[@]}"
do
  DOCKER_RUN_ARGS+=(
    "--env ${evar}"
  )
done
if [[ -t 0 ]] && [[ -t 1 ]]; then
  # stdin and stdout are open, assume it's an interactive tty session
  DOCKER_RUN_ARGS+=(
    "--interactive"
    "--tty"
  )
fi

if [[ ${VERBOSE} -eq 1 ]]; then
  set -o xtrace
fi
if [[ -z ${CMD} ]]; then
  # shellcheck disable=SC2068
  docker run \
    ${DOCKER_RUN_ARGS[@]} \
    "${IMAGE_TAGGED}"
else
  # shellcheck disable=SC2068
  docker run \
    ${DOCKER_RUN_ARGS[@]} \
    "${IMAGE_TAGGED}" \
    -c "$CMD"
fi
