#!/usr/bin/env bash

# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# Return an image:tag for the specified builder docker image
#     Given the input files (Dockerfile, configs, installation scripts etc) for building the docker
#     image, first generate a hash of the file contents (ie. exclude timestamps, file ownership etc).
#     This hash will be used as the image tag

set -o pipefail
set -o errexit

BUILD_IMAGE_IF_NEEDED=1
DOCKER_BUILD_ARGS="--quiet"

trap _cleanup EXIT
function _cleanup() {
  declare -r -i STATUS=$?
  if [[ -n ${TAR_IMAGE} ]]; then
    docker image rm --force "${TAR_IMAGE}" &>/dev/null
  fi
  if [[ -n ${TEMPTAR} ]]; then
    rm -f "${TEMPTAR}" "${SHAFILE}"
  fi
  if [[ ${STATUS} -ne 0 ]]; then
    printf "Error: get-builder-image-tagged status code: %d\n" ${STATUS} &>/dev/stderr
  fi
  exit ${STATUS}
}

function get_image_list() {
  declare -r _images_dir="$1"
  find "${_images_dir}" -maxdepth 1 -mindepth 1 -type d -printf "%P\n" | sort
}

function get_image_fullname() {
  declare -r _img="$1"
  declare -r _image_name=privacysandbox/builders/${_img}
  if [[ -z ${_image_name} ]]; then
    printf -- "error: image [%s] not recognized\n" "${_img}" &>/dev/stderr
    return 1
  fi
  printf "%s" "${_image_name}"
}

function usage() {
  declare -r -i exitval=${1-1}
  cat &>/dev/stderr <<USAGE
usage:
  $0 <options>
    --no-build           Do not build image if it doesn't exist
    --image              Image name for the build runtime. Valid names:
USAGE

  for elem in $(get_image_list "${IMAGES_DIR}")
  do
    if [[ ${IMAGE} == "${elem}" ]]; then
      local EXTRA=" (default)"
    fi
    printf "                             *  %s%s\n" "${elem}" "${EXTRA}" &>/dev/stderr
  done

  cat &>/dev/stderr <<USAGE
    --verbose            Enable verbose output
USAGE
  # shellcheck disable=SC2086
  exit ${exitval}
}

TOOLS_DIR="$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")"
readonly TOOLS_DIR
readonly ETC_DIR="${TOOLS_DIR}"/../etc
readonly IMAGES_DIR="${TOOLS_DIR}"/../images
# shellcheck disable=SC1091
source "${TOOLS_DIR}"/builder.sh
WORKSPACE_MOUNT="$(builder::get_docker_workspace_mount)"
readonly WORKSPACE_MOUNT

while [[ $# -gt 0 ]]; do
  case "$1" in
    --image)
      IMG="$2"
      shift
      shift
      ;;
    --no-build)
      BUILD_IMAGE_IF_NEEDED=0
      shift
      ;;
    --verbose)
      DOCKER_BUILD_ARGS="--progress plain"
      set -o xtrace
      shift
      ;;
    -h | --help) usage 0 ;;
    *)
      printf "unrecognized arg: %s\n" "$1"
      usage
      ;;
  esac
done

if [[ -z ${IMG} ]]; then
  printf -- "error: --image must be specified\n" &>/dev/stderr
  usage 1
fi

if ! IMAGE_NAME="$(get_image_fullname "${IMG}")"; then
  usage 1
fi
readonly IMAGE_NAME

IMAGE_PATH_FULL="${IMAGES_DIR}/${IMG}"
if ! [[ -s ${IMAGE_PATH_FULL}/Dockerfile ]]; then
  printf "error: unable to locate [%s/Dockerfile]\n" "${IMAGE_PATH_FULL}" &>/dev/stderr
  exit 1
fi

# install gnu tar into a docker image
readonly TAR_IMAGE="builders/tar-get-builder-image-tagged:pid-$$"
# shellcheck disable=SC2086
{
  cat <<Dockerfile
FROM alpine:3.16
RUN apk --no-cache add tar=1.34-r0
Dockerfile
} | docker buildx build ${DOCKER_BUILD_ARGS} --no-cache --output=type=docker --tag "${TAR_IMAGE}" - >/dev/null
if ! docker image inspect "${TAR_IMAGE}" &>/dev/null; then
  printf "error creating docker image [%s]\n" "${TAR_IMAGE}" &>/dev/stderr
  exit 1
fi

# Create a deterministic tar file for the specified file path, returning
# the SHA for the tar file content
# Any etc files in the $WORKSPACE (root) directory override the etc
# files in the image dir, as long as it's a file also found in the
# builders etc directory
# the TARFILE and SHAFILE args must be paths located in /tmp
function _tar_for_dir() {
  local -r FILE_TAR="$1"
  local -r FILE_SHA="$2"
  local -r FILEPATH="$3"
  local -r TMP_IMAGE_DIR="$(mktemp --tmpdir="${WORKSPACE}" --directory)"

  WS_FILE_TAR="$(realpath "${FILE_TAR}" --relative-to="${WORKSPACE}")"
  WS_FILE_SHA="$(realpath "${FILE_SHA}" --relative-to="${WORKSPACE}")"
  WS_FILEPATH="$(realpath "${FILEPATH}" --relative-to="${WORKSPACE}")"
  WS_TMP_IMAGE_DIR="$(realpath "${TMP_IMAGE_DIR}" --relative-to="${WORKSPACE}")"
  # find workspace etc files that are also in the image dir and the builders etc dir
  WORKSPACE_ETC_FILES="$({
    # shellcheck disable=SC2012
    ls -A -1 "${FILEPATH}" "${ETC_DIR}" | sort | uniq -d
    ls -A -1 "${WORKSPACE}"
  } | sort | uniq -d)"
  # create a deterministic tarball of the collected files
  docker run --rm \
    --entrypoint=/bin/sh \
    --volume "${WORKSPACE_MOUNT}":/workspace \
    --workdir /workspace \
    "${TAR_IMAGE}" -c "
tar --create --dereference --directory='${WS_FILEPATH}' --exclude=test . | tar --extract --overwrite --directory='${WS_TMP_IMAGE_DIR}'

# overwrite etc files in the image with the WORKSPACE's etc files
if [ -n '${WORKSPACE_ETC_FILES}' ]; then
  tar --create --dereference --exclude=test ${WORKSPACE_ETC_FILES} | tar --extract --overwrite --directory='${WS_TMP_IMAGE_DIR}'
fi

tar --create --dereference --sort=name --owner=0 --group=0 --numeric-owner --format=gnu --directory='${WS_TMP_IMAGE_DIR}' --file='${WS_FILE_TAR}' .
TARLEN=\$(wc -c <'${WS_FILE_TAR}')
{ printf 'blob %d\0' \${TARLEN}; tar --extract --file='${WS_FILE_TAR}' --to-stdout; } | sha256sum | cut -f1 -d' ' >'${WS_FILE_SHA}'
"
  rm -rf "${TMP_IMAGE_DIR}"
}

TEMPTAR=$(mktemp --tmpdir="${WORKSPACE}" --dry-run).tar.gz
readonly TEMPTAR
SHAFILE=$(mktemp --tmpdir="${WORKSPACE}" --dry-run).sha
readonly SHAFILE
# use the tarfile size and file content to generate a sha256 hash
_tar_for_dir "${TEMPTAR}" "${SHAFILE}" "${IMAGE_PATH_FULL}"
SHA=$(cat "${SHAFILE}")
ARCH="$("${TOOLS_DIR}"/get-architecture)"
readonly ARCH
readonly IMAGE_TAG="${ARCH}-${SHA}"
readonly IMAGE_TAGGED="${IMAGE_NAME}:${IMAGE_TAG}"
# generate output
printf "%s\n" "${IMAGE_TAGGED}"

if [[ ${BUILD_IMAGE_IF_NEEDED} -eq 1 ]]; then
  # Create a builder docker image
  # build container image and load it into the local docker client
  if ! docker image inspect "${IMAGE_TAGGED}" &>/dev/null; then
    printf "generating docker image %s\n" "${IMAGE_TAGGED}" &>/dev/stderr
    # shellcheck disable=SC2086
    docker buildx build ${DOCKER_BUILD_ARGS} --output=type=docker --tag "${IMAGE_TAGGED}" - <"${TEMPTAR}" &>/dev/stderr
  fi
fi
