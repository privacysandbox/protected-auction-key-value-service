/*
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef COMPONENTS_DATA_SERVER_REQUEST_HANDLER_COMPRESSION_COMPRESSION_H_
#define COMPONENTS_DATA_SERVER_REQUEST_HANDLER_COMPRESSION_COMPRESSION_H_

#include <memory>
#include <string>
#include <string_view>
#include <vector>

#include "absl/status/statusor.h"
#include "quiche/common/quiche_data_reader.h"

namespace kv_server {

// Responsible for concatenating compression groups according to the compression
// specification
// https://github.com/WICG/turtledove/blob/main/FLEDGE_Key_Value_Server_API.md#response-version-20
//
// Should not be reused across requests.
// Not intended to be used by multiple threads. Not thread-safe.
//
// Input to this object is one or more JSON strings, each being one compression
// group. Output of this object is a byte string concatenating all the
// compression groups using the defined protocol.
class CompressionGroupConcatenator {
 public:
  virtual ~CompressionGroupConcatenator() = default;

  enum class CompressionType { kUncompressed = 0, kBrotli /* TODO: kGzip */ };

  static std::unique_ptr<CompressionGroupConcatenator> Create(
      CompressionType type);
  using FactoryFunctionType = decltype(Create);

  // Adds the JSON representation of plaintext (uncompressed) to be
  // concatenated.
  void AddCompressionGroup(std::string plaintext_partition);

  // Compresses the input and generates the byte string that concatenates all
  // the compressed input.
  virtual absl::StatusOr<std::string> Build() const = 0;

 protected:
  const std::vector<std::string>& Partitions() const { return partitions_; }

 private:
  std::vector<std::string> partitions_;
};

// Responsible for parsing a compression blob generated by the
// CompressionGroupConcatenator. Should not be reused across requests. Not
// intended to be used by multiple threads. Not thread-safe.
class CompressedBlobReader {
 public:
  explicit CompressedBlobReader(std::string_view compressed)
      : data_reader_(compressed) {}

  static std::unique_ptr<CompressedBlobReader> Create(
      CompressionGroupConcatenator::CompressionType type,
      std::string_view compressed);

  virtual ~CompressedBlobReader() = default;

  // Returns true if no more compression group is left to extract.
  bool IsDoneReading() const { return data_reader_.IsDoneReading(); }

  // Decompresses one compression group and returns the JSON string. Changes the
  // reader state. The next call will return the next compression group.
  // Example:
  //
  // while (!compress_reader->IsDoneReading()) {
  //   if (auto maybe_one_group = compress_reader->ExtractOneCompressionGroup();
  //       maybe_one_group.ok()) {
  //     LOG(INFO) << "one group: " << *maybe_one_group;
  //   } else {...}
  // }
  virtual absl::StatusOr<std::string> ExtractOneCompressionGroup() = 0;

 protected:
  quiche::QuicheDataReader data_reader_;
};

}  // namespace kv_server

#endif  // COMPONENTS_DATA_SERVER_REQUEST_HANDLER_COMPRESSION_COMPRESSION_H_
